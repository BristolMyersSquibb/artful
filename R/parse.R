#' Remove empty rows
#'
#' This function removes empty rows (where all cells are empty strings) inside a
#' data frame generated by calling [rtf_to_html()].
#'
#' @param data A data frame generated by calling [rtf_to_html()].
#'
#' @return A data frame with empty rows removed.
#'
#' @keywords internal
strip_empty_rows <- function(data) {
  filter(data, !if_all(everything(), ~ . == ""))
}

#' Remove the header
#'
#' This function removes the rows representing a header (e.g., titles and
#' subtitles) inside a data frame generated by calling [rtf_to_html()].
#'
#' @param data A data frame generated by calling [rtf_to_html()].
#'
#' @return A data frame with the header removed.
#'
#' @keywords internal
strip_header <- function(data) {
  # The second+ columns are populated with empty strings "" alongside the
  # header information which can be used to determine the row indices of the
  # header:
  header_last_row <- min(which(data[[2]] != "" | is.na(data))) - 1

  # Some tables repeat across pages in the original RTF. This results in
  # data frames containing combined data frames with headers that repeat across
  # several points. Capture the original header:
  header <- slice(data, 1L:header_last_row)

  # Remove all copies of the header:
  data |>
    anti_join(header)
}

#' Remove the footer
#'
#' This function removes the rows representing a footer inside a data frame
#' generated by calling [rtf_to_html()].
#'
#' @param data A data frame generated by calling [rtf_to_html()].
#'
#' @return A data frame with the footer removed.
#'
#' @keywords internal
strip_footer <- function(data) {
  # The last row in the third column that is not an empty string signals the
  # last row before the footer. All following rows until the end of the data
  # frame are populated with empty strings alonside the footer values in
  # the first column.
  footer_first_row <- max(which(data[[3]] != "" | is.na(data[[3]]))) + 1

  # Some tables repeat across pages in the original RTF. This results in
  # data frames containing combined data frames with footers that repeat across
  # several points. Capture the original footer:
  footer <- slice(data, footer_first_row:nrow(data))

  # Remove all copies of the footer:
  data |>
    anti_join(footer)
}

#' Remove repeat column names
#'
#' This function removes columns names that repeat across multiple rows (caused
#' by pagination in the original RTF files) inside a data frame generated by
#' calling [rtf_to_html()]. Only the first occurance should be kept.
#'
#' @param data A data frame generated by calling [rtf_to_html()].
#'
#' @return A data frame with the repeat column names removed.
#'
#' @keywords internal
strip_repeat_colnames <- function(data) {
  # This assumes column names are in the first row (which is the case if this
  # function is called after calling `strip_header()`)
  first_row <- dplyr::slice(data, 1L)
  remaining_rows <- dplyr::slice(data, -1L)

  remaining_rows_without_colnames <- remaining_rows |>
    dplyr::anti_join(first_row)

  dplyr::bind_rows(first_row, remaining_rows_without_colnames)
}

#' Set column names
#'
#' This function sets columns names inside a data frame generated by calling
#' [rtf_to_html()]. It assumes the first row contains the actual column names.
#'
#' @param data A data frame generated by calling [rtf_to_html()].
#'
#' @return A data frame with the repeat column names removed.
#'
#' @keywords internal
set_colnames <- function(data) {
  # This assumes column names are in the first row (which is the case if this
  # function is called after calling `strip_header()`)
  colnames <- slice(data, 1L) |> as.character()

  # For any missing column names, it is assumed that the missing column can be
  # found on the first row of the corresponding column where all other columns
  # are empty strings.
  colnames_missing_indices <- which(colnames == "")

  for (i in colnames_missing_indices) {
    replacement <- filter(data, if_all(!i, ~ .x == "")) |>
      slice(1L) |>
      pull(i)
    colnames[i] <- replacement
  }

  data |>
    rename_with(~colnames) |>
    slice(-1L)
}

#' Strip pagination from a table
#'
#' This function combines the functionality of [strip_empty_rows()],
#' [strip_header()], [strip_footer()], [strip_repeat_colnames()], and
#' [set_colnames()] into a single function. If fine grained control is not
#' required to remove certain elements of a table, this function is preferred
#' because the actions of stripping table elements are dependent on each other
#' (e.g., to remove repeat column names, we first must identify these by
#' stripping the header).
#'
#' @param data A data frame generated by calling [rtf_to_html()].
#'
#' @return A data frame where pagination has been stripped.
#'
#' @keywords internal
strip_pagination <- function(data) {
  data <- strip_empty_rows(data)
  header_last_row <- min(which(data[[2]] != "" | is.na(data))) - 1
  header <- slice(data, 1:header_last_row)

  footer_first_row <- max(which(data[[3]] != "" | is.na(data[[3]]))) + 1
  footer <- slice(data, footer_first_row:nrow(data))

  colnames <- slice(data, header_last_row + 1)

  table_cells <- data |>
    anti_join(header) |>
    anti_join(footer) |>
    anti_join(colnames)

  non_paginated <- bind_rows(colnames, table_cells)

  colnames <- slice(non_paginated, 1L) |> as.character()
  colnames_missing_indices <- which(colnames == "")

  for (i in colnames_missing_indices) {
    replacement <- filter(non_paginated, if_all(!i, ~ .x == "")) |>
      slice(1L) |>
      pull(i)
    colnames[i] <- replacement
  }

  non_paginated |>
    rename_with(~colnames) |>
    slice(-1L)
}

#' Split a data frame into multiple tables by indentation
#'
#' This function splits a data frame into a list of data frames where each new
#' data frame contains the same repeated levels of indentation. Indentation is
#' determined by empty strings in the second column with the number of
#' consectuive empty strings in the first n rows representing n indentation
#' levels.
#'
#' @param data A data frame generated by calling [strip_pagination()].
#'
#' @return A list of data frames, each containing the same repeated levels of
#' indentation (represented by empty strings in the second column).
#'
#' @autoglobal
#' @keywords internal
split_data <- function(data) {
  data_with_table_flag <- data |>
    mutate(table_start = .data[[colnames(data)[[2]]]] == "")

  indents <- min(which(data[[2]] != "" | is.na(data))) - 1

  if (indents > 1) {
    for (i in 1:(indents - 1)) {
      data_with_table_flag <- data_with_table_flag |>
        mutate(
          shift_table_start = dplyr::lead(
            table_start,
            n = i,
            default = FALSE
          ),
          table_start = table_start & shift_table_start
        ) |>
        select(-shift_table_start)
    }
  }

  list_of_tables <- data_with_table_flag |>
    mutate(table_id = cumsum(table_start)) |>
    select(-table_start) |>
    group_split(table_id, .keep = FALSE)

  return(list_of_tables)
}

#' Pivot an indented data frame wider
#'
#' This function pivots indentation in a data frame into a wide format.
#' Indentation is determined by empty strings in the second column with the
#' number of consectuive empty strings in the first n rows representing n
#' indentation levels. For two levels of indentation, the first level of
#' indentation appears only once, at the top of the data frame. The second level
#' of indentation may appear n times through the data frame. This function only
#' supports indentation levels up to two. A more general solution to support
#' 2+ levels is sketched out in `inst/scripts/pivot-n.R`. For now, the simpler
#' solution below is preferred.
#'
#' @param data A data frame generated by calling [split_data()].
#'
#' @return A data frame with indentation removed and placed into new columns.
#'
#' @autoglobal
#' @keywords internal
pivot_indentation <- function(data) {
  indents <- min(which(data[[2]] != "" | is.na(data))) - 1

  if (indents == 1) {
    data |>
      slice(-1) |>
      mutate(variable_label1 = data[[1]][[1]])
  } else if (indents == 2) {
    data |>
      slice(-1) |>
      mutate(variable_label1 = data[[1]][[1]]) |>
      mutate(
        row = row_number(),
        is_label = (.data[[names(data)[2]]] == "" |
          is.na(.data[[names(data)[2]]]))
      ) |>
      mutate(label_id = if_else(is_label, row, NA_integer_)) |>
      fill(label_id, .direction = "down") |>
      mutate(
        variable_label2 = if_else(
          is_label,
          .data[[names(data)[1]]],
          NA_character_
        ),
        .by = label_id
      ) |>
      fill(variable_label2, .direction = "down") |>
      filter(!is_label) |>
      select(-row, -is_label, -label_id)
  } else {
    data
  }
}

#' Pivot a grouping variable longer
#'
#' The grouping variables in the final ARD are normally presented in a wide
#' format in the input RTF table. This functions pivots the grouping levels into
#' a long format.
#'
#' @param data A data frame with the grouping variable in a wide format.
#'
#' @return A data frame with the grouping variable in a long format.
#'
#' @keywords internal
pivot_group <- function(data) {
  data |>
    rename(variable_level = 1) |>
    pivot_longer(
      !starts_with("variable_"),
      names_to = "group1_level",
      values_to = "stat"
    ) |>
    mutate(group1 = "TRT", .before = 1) |>
    select(starts_with("group"), starts_with("variable"), starts_with("stat"))
}

#' Separate a single indented column into multiple columns
#'
#' This function separates a single indented column into multiple columns inside
#' a data frame generated by calling [rtf_to_html()]. Indentation is determined
#' by empty strings in the second column with the number of consectuive empty
#' strings in the first n rows representing n indentation levels.
#'
#' @param data A data frame generated by calling [strip_pagination()].
#'
#' @return A data frame where indented columns have been separated.
#'
#' @keywords internal
separate_indentation <- function(data) {
  data |>
    split_data() |>
    map(pivot_indentation) |>
    list_rbind()
}

#' Separate the Big N stat
#'
#' Extract the Big N stat and place it at the top of a table.
#'
#' @param data A data frame containing a column called "group1_level" which
#' contains the Big N statistic merged as part of the text.
#'
#' @return A data frame with the Big N stat separated and placed at the top.
#'
#' @autoglobal
#' @keywords internal
separate_bign <- function(data) {
  big_n <- data |>
    distinct(group1_level) |>
    separate_wider_regex(
      group1_level,
      patterns = c(
        variable_label1 = ".*?\\S+",
        "\\s+",
        "(?:\\(N = |N = )",
        stat = "\\d+",
        "\\)?"
      )
    ) |>
    mutate(stat_name = "N_header", stat_label = "N", .before = "stat")

  data <- data |>
    mutate(
      group1_level = stringr::str_extract(
        group1_level,
        ".*?\\S+(?=\\s*(?:\\(N = |N = ))"
      )
    )

  bind_rows(big_n, data) |>
    select(starts_with("group"), starts_with("variable"), starts_with("stat"))
}

#' Separate a merged columns into multiple columns
#'
#' This function separates columns containing merged values (e.g., where a count
#' and percentage are merged into a single string such as "34 (.56)") into
#' multiple columns inside a data frame generated by calling [rtf_to_html()].
#'
#' @param data A data frame generated by calling [rtf_to_html()].
#'
#' @return A data frame where merged columns have been separated.
#'
#' @keywords internal
separate_merges <- function(data) {
  # Placeholder
}

#' Separate a spanner
#'
#' This function separates spanning column labels out inside a data frame
#' generated by calling [rtf_to_html()]. A spanning column header represents a
#' unique grouping identifier for the columns it spans over.
#'
#' @param data A data frame generated by calling [rtf_to_html()].
#'
#' @return A data frame where merged columns have been separated.
#'
#' @keywords internal
separate_spanners <- function(data) {
  # Placeholder
}
