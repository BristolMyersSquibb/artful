library(tidyverse)
pkgload::load_all()

# ---- Slide 7 -----------------------------------------------------------------

# ---- rt-dm-demo.rtf ----

# Issue one: the second level of indentation for race and geography is not
# detected. This is lost when converting at the pandoc level. Given that
# indentation isn't lost on other tables, it is suspected that this is an issue
# with the supplied table rather than the conversion methodology used in this
# package.
html_file <- tempfile(fileext = ".html")

system.file("extdata", "rt-dm-demo.rtf", package = "artful") |>
  rtf_to_html() |>
  writeLines(html_file)

browseURL(html_file)

# Issue two: "<" and ">" symbols are sometimes dropped by during converson. This
# does not appear to be an issue with pandoc, but rather the unstandardised way
# the RTF tables are generated by suppliers. For example, we can use two
# different methods to programatically generate RTF tables containing "<" and
# ">" values and validate the conversion methods written in this package work as
# expected:

# Method one: gt package
rtf_gt <- tempfile(fileext = ".rtf")

data.frame(x = c("<= 10", ">= 10", "< 10", "> 10")) |>
  gt::gt() |>
  gt::gtsave(rtf_gt)

rtf_to_html(rtf_gt) |>
  html_to_dataframe()

# Method two: r2rtf package
rtf_r2rtf <- tempfile(fileext = ".rtf")

data.frame(x = c("<= 10", ">= 10", "< 10", "> 10")) |>
  r2rtf::rtf_body() |>
  r2rtf::rtf_encode() |>
  r2rtf::write_rtf(rtf_r2rtf)

rtf_to_html(rtf_r2rtf) |>
  html_to_dataframe()

# Attempt at ARD conversion:
system.file("extdata", "rt-dm-demo.rtf", package = "artful") |>
  rtf_to_html() |>
  html_to_dataframe() |>
  strip_pagination() |>
  separate_indentation() |>
  pivot_group() |>
  prinf()

# TODO: parse stats column

# ---- rt-dm-basedz.rtf ----

# Issue one: the raw table has misalgined columns which throws the reading off
# from the start. Is this intentional, or incorrectly supplied? Do we need to
# write some kind of checker which can manage offsets? Where do we draw the
# line?
html_file <- tempfile(fileext = ".html")

system.file("extdata", "rt-dm-basedz.rtf", package = "artful") |>
  rtf_to_html() |>
  writeLines(html_file)

browseURL(html_file)

# We can attempt to shift these column names, but I predict we will end up with
# many conflicting heuristics which will cause repeat failures and an unstable
# product.
shift_col_right <- function(df, shift_row = 2L, delete_col = 2L) {
  pattern_row <- as.character(df[shift_row, ])
  result <- map_dfr(
    .x = 1:nrow(df),
    .f = \(x) {
      current_row <- as.character(df[x, ])
      if (identical(current_row, pattern_row)) {
        shifted <- c("", current_row[-length(current_row)])
      } else {
        shifted <- current_row
      }
      tibble(!!!set_names(shifted[-delete_col], names(df)[-delete_col]))
    }
  )
  return(result)
}

system.file("extdata", "rt-dm-basedz.rtf", package = "artful") |>
  rtf_to_html() |>
  html_to_dataframe() |>
  shift_col_right() |>
  View()
strip_pagination() |>
  separate_indentation() |>
  pivot_group() |>
  View()

# Issue two: the second level of indentation is dropped. In this instance it is
# because there is a mixture in the number of indents throughout the table. This
# is contrast to something like bms-1 through bms-5 where the indents are always
# consistent. The current heuristic resets indentation by looking out for
# repeated levels of indentation. This means it fails for this example as the
# indentation levels vary and don't repeat. We can't infer second levels of
# indentations based off empty rows because they signify both a break in the
# same number of indentation, and a new level of indentation. The only solution
# is to keep the original indented whitespace and use that to determine
# indentation. But, the current solution strips whitespace as HTML collapses
# multiple spaces by default:
html_file <- tempfile(fileext = ".html")

system.file("extdata", "rt-dm-basedz.rtf", package = "artful") |>
  rtf_to_html() |>
  writeLines(html_file)

browseURL(html_file)

# Solutions to maintain whitespace:
# - First, read in stream of rtf tables, and then use some regex / string
#   manipulation to replace spaces with non-breaking spaces that will be
#   maintained during the conversion: https://github.com/jgm/pandoc/issues/10077
#   can we use the literal "{  <INSERT TEXT>\cell}" to identify cells within
#   which we can replace the spaces with non-breaking spaces or something
#   pandoc respects
# - Second, find a system2() call to pandoc which maintains spaces, if possible.

# This partially works
process_rtf_whitespace <- function(path) {
  read_file(path) %>%
    str_replace_all("(\\{)( +)(.*?\\\\cell\\})", "\\1&nbsp;\\3")
}

# This doesn't work
process_rtf_whitespace <- function(rtf_path) {
  read_file(rtf_path) |>
    str_replace_all("  ", "&nbsp;&nbsp;")
}

temp_rtf <- tempfile(fileext = ".rtf")
temp_html <- tempfile(fileext = ".html")

system.file("extdata", "rt-dm-basedz.rtf", package = "artful") |>
  process_rtf_whitespace() |>
  writeLines(temp_rtf)

rtf_to_html(temp_rtf) |>
  writeLines(temp_html)

# ---- Slide 8 -----------------------------------------------------------------
# rt-ds-pretrt.rtf
# rt-ds-trtwk16.rtf

# ---- Slide 9 -----------------------------------------------------------------
# rt-ef-acr20.rtf
# rt-ef-aacr50.rtf
# rt-ef-aacr70.rtf
